import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/keymaster/keymaster.js
var require_keymaster = __commonJS({
  "node_modules/keymaster/keymaster.js"(exports, module) {
    (function(global) {
      var k, _handlers = {}, _mods = { 16: false, 18: false, 17: false, 91: false }, _scope = "all", _MODIFIERS = {
        "⇧": 16,
        shift: 16,
        "⌥": 18,
        alt: 18,
        option: 18,
        "⌃": 17,
        ctrl: 17,
        control: 17,
        "⌘": 91,
        command: 91
      }, _MAP = {
        backspace: 8,
        tab: 9,
        clear: 12,
        enter: 13,
        "return": 13,
        esc: 27,
        escape: 27,
        space: 32,
        left: 37,
        up: 38,
        right: 39,
        down: 40,
        del: 46,
        "delete": 46,
        home: 36,
        end: 35,
        pageup: 33,
        pagedown: 34,
        ",": 188,
        ".": 190,
        "/": 191,
        "`": 192,
        "-": 189,
        "=": 187,
        ";": 186,
        "'": 222,
        "[": 219,
        "]": 221,
        "\\": 220
      }, code = function(x) {
        return _MAP[x] || x.toUpperCase().charCodeAt(0);
      }, _downKeys = [];
      for (k = 1; k < 20; k++)
        _MAP["f" + k] = 111 + k;
      function index(array, item) {
        var i = array.length;
        while (i--)
          if (array[i] === item)
            return i;
        return -1;
      }
      function compareArray(a1, a2) {
        if (a1.length != a2.length)
          return false;
        for (var i = 0; i < a1.length; i++) {
          if (a1[i] !== a2[i])
            return false;
        }
        return true;
      }
      var modifierMap = {
        16: "shiftKey",
        18: "altKey",
        17: "ctrlKey",
        91: "metaKey"
      };
      function updateModifierKey(event) {
        for (k in _mods)
          _mods[k] = event[modifierMap[k]];
      }
      ;
      function dispatch(event) {
        var key2, handler, k2, i, modifiersMatch, scope;
        key2 = event.keyCode;
        if (index(_downKeys, key2) == -1) {
          _downKeys.push(key2);
        }
        if (key2 == 93 || key2 == 224)
          key2 = 91;
        if (key2 in _mods) {
          _mods[key2] = true;
          for (k2 in _MODIFIERS)
            if (_MODIFIERS[k2] == key2)
              assignKey[k2] = true;
          return;
        }
        updateModifierKey(event);
        if (!assignKey.filter.call(this, event))
          return;
        if (!(key2 in _handlers))
          return;
        scope = getScope();
        for (i = 0; i < _handlers[key2].length; i++) {
          handler = _handlers[key2][i];
          if (handler.scope == scope || handler.scope == "all") {
            modifiersMatch = handler.mods.length > 0;
            for (k2 in _mods)
              if (!_mods[k2] && index(handler.mods, +k2) > -1 || _mods[k2] && index(handler.mods, +k2) == -1)
                modifiersMatch = false;
            if (handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch) {
              if (handler.method(event, handler) === false) {
                if (event.preventDefault)
                  event.preventDefault();
                else
                  event.returnValue = false;
                if (event.stopPropagation)
                  event.stopPropagation();
                if (event.cancelBubble)
                  event.cancelBubble = true;
              }
            }
          }
        }
      }
      ;
      function clearModifier(event) {
        var key2 = event.keyCode, k2, i = index(_downKeys, key2);
        if (i >= 0) {
          _downKeys.splice(i, 1);
        }
        if (key2 == 93 || key2 == 224)
          key2 = 91;
        if (key2 in _mods) {
          _mods[key2] = false;
          for (k2 in _MODIFIERS)
            if (_MODIFIERS[k2] == key2)
              assignKey[k2] = false;
        }
      }
      ;
      function resetModifiers() {
        for (k in _mods)
          _mods[k] = false;
        for (k in _MODIFIERS)
          assignKey[k] = false;
      }
      ;
      function assignKey(key2, scope, method) {
        var keys, mods;
        keys = getKeys(key2);
        if (method === void 0) {
          method = scope;
          scope = "all";
        }
        for (var i = 0; i < keys.length; i++) {
          mods = [];
          key2 = keys[i].split("+");
          if (key2.length > 1) {
            mods = getMods(key2);
            key2 = [key2[key2.length - 1]];
          }
          key2 = key2[0];
          key2 = code(key2);
          if (!(key2 in _handlers))
            _handlers[key2] = [];
          _handlers[key2].push({ shortcut: keys[i], scope, method, key: keys[i], mods });
        }
      }
      ;
      function unbindKey(key2, scope) {
        var multipleKeys, keys, mods = [], i, j, obj;
        multipleKeys = getKeys(key2);
        for (j = 0; j < multipleKeys.length; j++) {
          keys = multipleKeys[j].split("+");
          if (keys.length > 1) {
            mods = getMods(keys);
            key2 = keys[keys.length - 1];
          }
          key2 = code(key2);
          if (scope === void 0) {
            scope = getScope();
          }
          if (!_handlers[key2]) {
            return;
          }
          for (i = 0; i < _handlers[key2].length; i++) {
            obj = _handlers[key2][i];
            if (obj.scope === scope && compareArray(obj.mods, mods)) {
              _handlers[key2][i] = {};
            }
          }
        }
      }
      ;
      function isPressed2(keyCode) {
        if (typeof keyCode == "string") {
          keyCode = code(keyCode);
        }
        return index(_downKeys, keyCode) != -1;
      }
      function getPressedKeyCodes() {
        return _downKeys.slice(0);
      }
      function filter(event) {
        var tagName = (event.target || event.srcElement).tagName;
        return !(tagName == "INPUT" || tagName == "SELECT" || tagName == "TEXTAREA");
      }
      for (k in _MODIFIERS)
        assignKey[k] = false;
      function setScope(scope) {
        _scope = scope || "all";
      }
      ;
      function getScope() {
        return _scope || "all";
      }
      ;
      function deleteScope(scope) {
        var key2, handlers, i;
        for (key2 in _handlers) {
          handlers = _handlers[key2];
          for (i = 0; i < handlers.length; ) {
            if (handlers[i].scope === scope)
              handlers.splice(i, 1);
            else
              i++;
          }
        }
      }
      ;
      function getKeys(key2) {
        var keys;
        key2 = key2.replace(/\s/g, "");
        keys = key2.split(",");
        if (keys[keys.length - 1] == "") {
          keys[keys.length - 2] += ",";
        }
        return keys;
      }
      function getMods(key2) {
        var mods = key2.slice(0, key2.length - 1);
        for (var mi = 0; mi < mods.length; mi++)
          mods[mi] = _MODIFIERS[mods[mi]];
        return mods;
      }
      function addEvent(object, event, method) {
        if (object.addEventListener)
          object.addEventListener(event, method, false);
        else if (object.attachEvent)
          object.attachEvent("on" + event, function() {
            method(window.event);
          });
      }
      ;
      addEvent(document, "keydown", function(event) {
        dispatch(event);
      });
      addEvent(document, "keyup", clearModifier);
      addEvent(window, "focus", resetModifiers);
      var previousKey = global.key;
      function noConflict() {
        var k2 = global.key;
        global.key = previousKey;
        return k2;
      }
      global.key = assignKey;
      global.key.setScope = setScope;
      global.key.getScope = getScope;
      global.key.deleteScope = deleteScope;
      global.key.filter = filter;
      global.key.isPressed = isPressed2;
      global.key.getPressedKeyCodes = getPressedKeyCodes;
      global.key.noConflict = noConflict;
      global.key.unbind = unbindKey;
      if (typeof module !== "undefined")
        module.exports = assignKey;
    })(exports);
  }
});

// node_modules/react-tetris/lib/components/Tetris.js
var import_react7 = __toESM(require_react());

// node_modules/react-tetris/lib/components/Gameboard.js
var import_react2 = __toESM(require_react());

// node_modules/react-tetris/lib/constants.js
var constants_default = {
  // dimensions in "cells"
  GAME_WIDTH: 10,
  GAME_HEIGHT: 20,
  BLOCK_WIDTH: 4,
  BLOCK_HEIGHT: 4,
  ROTATION_COUNT: 4
};

// node_modules/react-tetris/lib/models/Piece.js
var pieces = ["I", "J", "L", "O", "S", "T", "Z"];
var isRotation = function(num) {
  return num >= 0 && num < constants_default.ROTATION_COUNT;
};
var getBlocks = function(piece) {
  switch (piece) {
    case "I":
      return [
        [
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0]
        ],
        [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0]
        ],
        [
          [0, 0, 0, 0],
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0]
        ]
      ];
    case "J":
      return [
        [
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 0, 0, 0],
          [1, 1, 1, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 0, 0, 0],
          [1, 1, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 0]
        ]
      ];
    case "L":
      return [
        [
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 1, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 0, 0, 0],
          [1, 1, 1, 0],
          [1, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 0, 1, 0],
          [1, 1, 1, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ]
      ];
    case "O":
      return [
        [
          [1, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ]
      ];
    case "S":
      return [
        [
          [0, 0, 0, 0],
          [0, 1, 1, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 0, 0, 0],
          [1, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 1, 0],
          [1, 1, 0, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 0, 0],
          [0, 1, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 0, 0]
        ]
      ];
    case "T":
      return [
        [
          [0, 0, 0, 0],
          [1, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 0, 0],
          [1, 1, 0, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 0, 0],
          [1, 1, 1, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 0, 0],
          [0, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ]
      ];
    case "Z":
      return [
        [
          [0, 0, 0, 0],
          [1, 1, 0, 0],
          [0, 1, 1, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 1, 0, 0],
          [1, 1, 0, 0],
          [1, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [1, 1, 0, 0],
          [0, 1, 1, 0],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ],
        [
          [0, 0, 1, 0],
          [0, 1, 1, 0],
          [0, 1, 0, 0],
          [0, 0, 0, 0]
        ]
      ];
    default: {
      var exhaustiveCheck = piece;
      throw new Error("Unhandled color case: ".concat(exhaustiveCheck));
    }
  }
};
var getClassName = function(piece) {
  switch (piece) {
    case "I":
      return "piece-i";
    case "J":
      return "piece-j";
    case "L":
      return "piece-l";
    case "O":
      return "piece-o";
    case "S":
      return "piece-s";
    case "T":
      return "piece-t";
    case "Z":
      return "piece-z";
    case "ghost":
      return "piece-preview";
    default: {
      var exhaustiveCheck = piece;
      throw new Error("Unhandled piece case: ".concat(exhaustiveCheck));
    }
  }
};

// node_modules/react-tetris/lib/models/Matrix.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var GAME_HEIGHT = constants_default.GAME_HEIGHT;
var GAME_WIDTH = constants_default.GAME_WIDTH;
var serializeCoords = function(_a) {
  var x = _a.x, y = _a.y;
  return "".concat(x, ",").concat(y);
};
function buildMatrix() {
  var matrix = new Array(GAME_HEIGHT);
  for (var y = 0; y < matrix.length; y++) {
    matrix[y] = buildGameRow();
  }
  return matrix;
}
function buildGameRow() {
  return new Array(GAME_WIDTH).fill(null);
}
var addPieceToBoard = function(matrix, positionedPiece, isGhost) {
  if (isGhost === void 0) {
    isGhost = false;
  }
  var piece = positionedPiece.piece, rotation = positionedPiece.rotation, position = positionedPiece.position;
  var block = getBlocks(piece)[rotation];
  if (!block) {
    throw new Error("Unexpected: no rotation ".concat(rotation, " found to piece ").concat(piece));
  }
  var filledCells = block.reduce(function(output, row, y) {
    return output.concat(row.map(function(cell, x) {
      return cell ? { x: x + position.x, y: y + position.y } : false;
    }));
  }, []);
  var filled = new Set(filledCells.map(function(value2) {
    return value2 ? serializeCoords(value2) : "";
  }).filter(Boolean));
  var value = isGhost ? "ghost" : piece;
  return matrix.map(function(row, y) {
    return row.map(function(cell, x) {
      return filled.has(serializeCoords({ x, y })) ? value : cell;
    });
  });
};
function setPiece(matrix, positionedPiece) {
  var _matrix = addPieceToBoard(matrix, positionedPiece);
  var linesCleared = clearFullLines(_matrix);
  return [_matrix, linesCleared];
}
function clearFullLines(matrix) {
  var linesCleared = 0;
  for (var y = 0; y < matrix.length; y++) {
    if (every(matrix[y])) {
      matrix.splice(y, 1);
      matrix.unshift(buildGameRow());
      linesCleared += 1;
    }
  }
  return linesCleared;
}
function every(list) {
  for (var i = 0; i < list.length; i++) {
    if (!list[i])
      return false;
  }
  return true;
}
function isEmptyPosition(matrix, positionedPiece) {
  var piece = positionedPiece.piece, rotation = positionedPiece.rotation, position = positionedPiece.position;
  var blocks = getBlocks(piece)[rotation];
  for (var x = 0; x < constants_default.BLOCK_WIDTH; x++) {
    for (var y = 0; y < constants_default.BLOCK_HEIGHT; y++) {
      var block = blocks[y][x];
      var matrixX = x + position.x;
      var matrixY = y + position.y;
      if (block) {
        if (matrixX >= 0 && matrixX < GAME_WIDTH && matrixY < GAME_HEIGHT) {
          if (!matrix[matrixY] || matrix[matrixY][matrixX]) {
            return false;
          }
        } else {
          return false;
        }
      }
    }
  }
  return true;
}
function assert(value) {
  if (!value)
    throw new Error("assertion failed");
}
function tryMove(move) {
  return function(gameboard, positionedPiece) {
    var updatedPiece = move(positionedPiece);
    if (isEmptyPosition(gameboard, updatedPiece)) {
      return updatedPiece;
    }
    return void 0;
  };
}
var moveLeft = tryMove(function(positionedPiece) {
  var newPosition = __assign(__assign({}, positionedPiece.position), { x: positionedPiece.position.x - 1 });
  return __assign(__assign({}, positionedPiece), { position: newPosition });
});
var moveRight = tryMove(function(positionedPiece) {
  var newPosition = __assign(__assign({}, positionedPiece.position), { x: positionedPiece.position.x + 1 });
  return __assign(__assign({}, positionedPiece), { position: newPosition });
});
var moveDown = tryMove(function(positionedPiece) {
  var newPosition = __assign(__assign({}, positionedPiece.position), { y: positionedPiece.position.y + 1 });
  return __assign(__assign({}, positionedPiece), { position: newPosition });
});
var flipClockwise = tryMove(function(positionedPiece) {
  var _a;
  var rotation = (((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) + 1) % constants_default.ROTATION_COUNT;
  assert(isRotation(rotation));
  return __assign(__assign({}, positionedPiece), { rotation });
});
var flipCounterclockwise = tryMove(function(positionedPiece) {
  var _a;
  var rotation = ((_a = positionedPiece.rotation) !== null && _a !== void 0 ? _a : 0) - 1;
  if (rotation < 0)
    rotation += constants_default.ROTATION_COUNT;
  assert(isRotation(rotation));
  return __assign(__assign({}, positionedPiece), { rotation });
});
function hardDrop(gameboard, positionedPiece) {
  var position = __assign({}, positionedPiece.position);
  while (isEmptyPosition(gameboard, __assign(__assign({}, positionedPiece), { position }))) {
    position.y += 1;
  }
  position.y -= 1;
  return __assign(__assign({}, positionedPiece), { position });
}

// node_modules/react-tetris/lib/modules/piece-queue.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function create(minimumLength) {
  return fill({
    minimumLength,
    queue: [],
    bucket: []
  });
}
function fill(pieceQueue) {
  var local = [];
  var bucket = pieceQueue.bucket;
  while (local.length + pieceQueue.queue.length < pieceQueue.minimumLength) {
    var _a = pullFromBucket(bucket), piece = _a[0], updatedBucket = _a[1];
    local.push(piece);
    bucket = updatedBucket;
  }
  return __assign2(__assign2({}, pieceQueue), { queue: pieceQueue.queue.concat(local) });
}
function getNext(pieceQueue) {
  if (!pieceQueue.queue[0]) {
    throw new Error("Unexpected empty queue");
  }
  var next = pieceQueue.queue[0];
  var queue = pieceQueue.queue.slice(1);
  return {
    piece: next,
    queue: fill(__assign2(__assign2({}, pieceQueue), { queue }))
  };
}
function pullFromBucket(bucket) {
  var local = bucket.slice(0);
  if (local.length === 0) {
    pieces.forEach(function(piece) {
      for (var i = 0; i < 4; i++) {
        local.push(piece);
      }
    });
  }
  var randomPiece = local.splice(randomNumber(local.length), 1)[0];
  if (!randomPiece) {
    console.error("bucket:", JSON.stringify(local));
    throw new Error("Unexpected: failed to pull from bucket");
  }
  return [randomPiece, local];
}
function randomNumber(under) {
  return Math.floor(Math.random() * under);
}

// node_modules/react-tetris/lib/models/Game.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var getLevel = function(game) {
  return Math.floor(game.lines / 10) + 1;
};
var update = function(game, action) {
  var _a, _b;
  switch (action) {
    case "RESTART": {
      return init();
    }
    case "PAUSE": {
      return game.state === "PLAYING" ? __assign3(__assign3({}, game), { state: "PAUSED" }) : game;
    }
    case "RESUME": {
      return game.state === "PAUSED" ? __assign3(__assign3({}, game), { state: "PLAYING" }) : game;
    }
    case "TOGGLE_PAUSE": {
      if (game.state === "PLAYING")
        return __assign3(__assign3({}, game), { state: "PAUSED" });
      if (game.state === "PAUSED")
        return __assign3(__assign3({}, game), { state: "PLAYING" });
      return game;
    }
    case "HARD_DROP": {
      if (game.state !== "PLAYING")
        return game;
      var piece = hardDrop(game.matrix, game.piece);
      return lockInPiece(__assign3(__assign3({}, game), { piece }));
    }
    case "TICK":
    case "MOVE_DOWN": {
      if (game.state !== "PLAYING")
        return game;
      var updated = applyMove(moveDown, game);
      if (game.piece === updated.piece) {
        return lockInPiece(updated);
      } else {
        return updated;
      }
    }
    case "MOVE_LEFT": {
      return applyMove(moveLeft, game);
    }
    case "MOVE_RIGHT": {
      return applyMove(moveRight, game);
    }
    case "FLIP_CLOCKWISE": {
      return applyMove(flipClockwise, game);
    }
    case "FLIP_COUNTERCLOCKWISE": {
      return applyMove(flipCounterclockwise, game);
    }
    case "HOLD": {
      if (game.state !== "PLAYING")
        return game;
      if (game.heldPiece && !game.heldPiece.available)
        return game;
      if (game.heldPiece && !isEmptyPosition(game.matrix, __assign3(__assign3({}, game.piece), { piece: game.heldPiece.piece }))) {
        return game;
      }
      var next = getNext(game.queue);
      var newPiece = (_b = (_a = game.heldPiece) === null || _a === void 0 ? void 0 : _a.piece) !== null && _b !== void 0 ? _b : next.piece;
      return __assign3(__assign3({}, game), { heldPiece: { piece: game.piece.piece, available: false }, piece: initializePiece(newPiece), queue: newPiece === next.piece ? next.queue : game.queue });
    }
  }
};
var lockInPiece = function(game) {
  var _a = setPiece(game.matrix, game.piece), matrix = _a[0], linesCleared = _a[1];
  var next = getNext(game.queue);
  var piece = initializePiece(next.piece);
  return __assign3(__assign3({}, game), { state: isEmptyPosition(matrix, piece) ? game.state : "LOST", matrix, piece, heldPiece: game.heldPiece ? __assign3(__assign3({}, game.heldPiece), { available: true }) : void 0, queue: next.queue, lines: game.lines + linesCleared, points: game.points + addScore(linesCleared) });
};
var pointsPerLine = 100;
var addScore = function(additionalLines) {
  if (additionalLines === 4) {
    return pointsPerLine * 10;
  } else {
    return additionalLines * pointsPerLine;
  }
};
var initialPosition = {
  x: constants_default.GAME_WIDTH / 2 - constants_default.BLOCK_WIDTH / 2,
  y: 0
};
var initializePiece = function(piece) {
  return {
    position: initialPosition,
    piece,
    rotation: 0
  };
};
var applyMove = function(move, game) {
  if (game.state !== "PLAYING")
    return game;
  var afterFlip = move(game.matrix, game.piece);
  return afterFlip ? __assign3(__assign3({}, game), { piece: afterFlip }) : game;
};
var init = function() {
  var queue = create(5);
  var next = getNext(queue);
  return {
    state: "PLAYING",
    points: 0,
    lines: 0,
    matrix: buildMatrix(),
    piece: initializePiece(next.piece),
    heldPiece: void 0,
    queue: next.queue
  };
};
function viewMatrix(game) {
  var gameboard = game.matrix;
  gameboard = addPieceToBoard(gameboard, hardDrop(gameboard, game.piece), true);
  return addPieceToBoard(gameboard, game.piece);
}

// node_modules/react-tetris/lib/context.js
var import_react = __toESM(require_react());
var Context = import_react.default.createContext(init());

// node_modules/react-tetris/lib/components/Gameboard.js
function GameboardView() {
  var game = import_react2.default.useContext(Context);
  var matrix = viewMatrix(game);
  return import_react2.default.createElement(
    "table",
    { className: "game-board" },
    import_react2.default.createElement("tbody", null, matrix.map(function(row, i) {
      var blocksInRow = row.map(function(block, j) {
        var classString = "game-block ".concat(block ? getClassName(block) : "block-empty");
        return import_react2.default.createElement("td", { key: j, className: classString });
      });
      return import_react2.default.createElement("tr", { key: i }, blocksInRow);
    }))
  );
}

// node_modules/react-tetris/lib/components/HeldPiece.js
var import_react4 = __toESM(require_react());

// node_modules/react-tetris/lib/components/PieceView.js
var import_react3 = __toESM(require_react());
var defaultBlock = [
  [0, 0, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 0, 0],
  [0, 0, 0, 0]
];
var PieceView = function(_a) {
  var piece = _a.piece;
  var fromPiece = piece && getBlocks(piece)[0];
  var blocks = fromPiece !== null && fromPiece !== void 0 ? fromPiece : defaultBlock;
  var rows = blocks.map(function(row, i) {
    var blocksInRow = row.map(function(block, j) {
      var classString = "game-block ";
      if (piece && block) {
        classString += getClassName(piece);
      } else {
        classString += "block-empty";
      }
      return import_react3.default.createElement("td", { key: j, className: classString });
    });
    return import_react3.default.createElement("tr", { key: i }, blocksInRow);
  });
  return import_react3.default.createElement(
    "table",
    { className: "piece-view" },
    import_react3.default.createElement("tbody", null, rows)
  );
};
var PieceView_default = PieceView;

// node_modules/react-tetris/lib/components/HeldPiece.js
function HeldPiece() {
  var heldPiece = import_react4.default.useContext(Context).heldPiece;
  return import_react4.default.createElement(PieceView_default, { piece: heldPiece === null || heldPiece === void 0 ? void 0 : heldPiece.piece });
}

// node_modules/react-tetris/lib/components/PieceQueue.js
var import_react5 = __toESM(require_react());
function PieceQueue() {
  var queue = import_react5.default.useContext(Context).queue;
  return import_react5.default.createElement("div", null, queue.queue.map(function(piece, i) {
    return import_react5.default.createElement(PieceView_default, { piece, key: i });
  }));
}

// node_modules/react-tetris/lib/hooks/useKeyboardControls.js
var import_react6 = __toESM(require_react());
var import_keymaster = __toESM(require_keymaster());

// node_modules/react-tetris/lib/modules/detect-shift.js
var callbacks = [];
var isPressed = false;
document.addEventListener("keydown", function(e) {
  if (e.shiftKey && !isPressed) {
    isPressed = e.shiftKey;
    callCallbacks();
  }
  return true;
});
document.addEventListener("keyup", function(e) {
  if (!e.shiftKey && isPressed) {
    isPressed = e.shiftKey;
  }
  return true;
});
function callCallbacks() {
  callbacks.forEach(function(callback) {
    callback();
  });
}
var detect_shift_default = {
  bind: function(callback) {
    callbacks.push(callback);
  },
  unbind: function(callback) {
    var index = callbacks.indexOf(callback);
    if (index !== -1) {
      callbacks.splice(index, 1);
    }
  }
};

// node_modules/react-tetris/lib/hooks/useKeyboardControls.js
var useKeyboardControls = function(keyboardMap, dispatch) {
  import_react6.default.useEffect(function() {
    var keyboardDispatch = Object.entries(keyboardMap).reduce(function(output, _a) {
      var key2 = _a[0], action = _a[1];
      output[key2] = function() {
        return dispatch(action);
      };
      return output;
    }, {});
    addKeyboardEvents(keyboardDispatch);
    return function() {
      return removeKeyboardEvents(keyboardDispatch);
    };
  }, [keyboardMap, dispatch]);
};
function addKeyboardEvents(keyboardMap) {
  Object.keys(keyboardMap).forEach(function(k) {
    var fn = keyboardMap[k];
    if (k === "shift" && fn) {
      detect_shift_default.bind(fn);
    } else if (fn) {
      (0, import_keymaster.default)(k, fn);
    }
  });
}
function removeKeyboardEvents(keyboardMap) {
  Object.keys(keyboardMap).forEach(function(k) {
    if (k === "shift") {
      var fn = keyboardMap[k];
      fn && detect_shift_default.unbind(fn);
    } else {
      import_keymaster.default.unbind(k);
    }
  });
}

// node_modules/react-tetris/lib/components/Tetris.js
var defaultKeyboardMap = {
  down: "MOVE_DOWN",
  left: "MOVE_LEFT",
  right: "MOVE_RIGHT",
  space: "HARD_DROP",
  z: "FLIP_COUNTERCLOCKWISE",
  x: "FLIP_CLOCKWISE",
  up: "FLIP_CLOCKWISE",
  p: "TOGGLE_PAUSE",
  c: "HOLD",
  shift: "HOLD"
};
var tickSeconds = function(level) {
  return Math.pow(0.8 - (level - 1) * 7e-3, level - 1);
};
function Tetris(props) {
  var _a;
  var _b = import_react7.default.useReducer(update, init()), game = _b[0], dispatch = _b[1];
  var keyboardMap = (_a = props.keyboardControls) !== null && _a !== void 0 ? _a : defaultKeyboardMap;
  useKeyboardControls(keyboardMap, dispatch);
  var level = getLevel(game);
  import_react7.default.useEffect(function() {
    var interval;
    if (game.state === "PLAYING") {
      interval = window.setInterval(function() {
        dispatch("TICK");
      }, tickSeconds(level) * 1e3);
    }
    return function() {
      window.clearInterval(interval);
    };
  }, [game.state, level]);
  var controller = import_react7.default.useMemo(function() {
    return {
      pause: function() {
        return dispatch("PAUSE");
      },
      resume: function() {
        return dispatch("RESUME");
      },
      hold: function() {
        return dispatch("HOLD");
      },
      hardDrop: function() {
        return dispatch("HARD_DROP");
      },
      moveDown: function() {
        return dispatch("MOVE_DOWN");
      },
      moveLeft: function() {
        return dispatch("MOVE_LEFT");
      },
      moveRight: function() {
        return dispatch("MOVE_RIGHT");
      },
      flipClockwise: function() {
        return dispatch("FLIP_CLOCKWISE");
      },
      flipCounterclockwise: function() {
        return dispatch("FLIP_COUNTERCLOCKWISE");
      },
      restart: function() {
        return dispatch("RESTART");
      }
    };
  }, [dispatch]);
  return import_react7.default.createElement(Context.Provider, { value: game }, props.children({
    HeldPiece,
    Gameboard: GameboardView,
    PieceQueue,
    points: game.points,
    linesCleared: game.lines,
    state: game.state,
    level,
    controller
  }));
}
export {
  Tetris as default
};
//# sourceMappingURL=react-tetris.js.map
