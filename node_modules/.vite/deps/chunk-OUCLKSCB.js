// node_modules/@legendapp/state/index.mjs
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isArray(obj) {
  return Array.isArray(obj);
}
function isString(obj) {
  return typeof obj === "string";
}
function isObject(obj) {
  return !!obj && typeof obj === "object" && !isArray(obj);
}
function isFunction(obj) {
  return typeof obj === "function";
}
function isPrimitive(arg) {
  const type = typeof arg;
  return arg !== void 0 && type !== "object" && type !== "function";
}
function isSymbol(obj) {
  return typeof obj === "symbol";
}
function isBoolean(obj) {
  return typeof obj === "boolean";
}
function isPromise(obj) {
  return obj instanceof Promise;
}
function isEmpty(obj) {
  if (!obj)
    return false;
  if (isArray(obj))
    return obj.length === 0;
  for (const key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
var setPrimitives = /* @__PURE__ */ new Set(["boolean", "string", "number"]);
function isActualPrimitive(arg) {
  return setPrimitives.has(typeof arg);
}
function isChildNodeValue(node) {
  return !!node.parent;
}
var trackCount = 0;
var trackingQueue = [];
var tracking = {
  current: void 0,
  inRender: false
};
function beginTracking(inRender) {
  trackingQueue.push(tracking.current);
  trackCount++;
  tracking.inRender = inRender;
  tracking.current = {};
}
function endTracking(fromRender) {
  trackCount--;
  if (trackCount < 0) {
    trackCount = 0;
  }
  if (fromRender) {
    tracking.inRender = false;
  }
  tracking.current = trackingQueue.pop();
}
function updateTracking(node, track) {
  if (trackCount) {
    const tracker = tracking.current;
    if (tracker) {
      if (!tracker.nodes) {
        tracker.nodes = /* @__PURE__ */ new Map();
      }
      const existing = tracker.nodes.get(node);
      if (existing) {
        existing.track = existing.track || track;
        existing.num++;
      } else {
        tracker.nodes.set(node, { node, track, num: 1 });
      }
    }
  }
}
var symbolToPrimitive = Symbol.toPrimitive;
var symbolGetNode = Symbol("getNode");
var symbolDelete = Symbol("delete");
var symbolOpaque = Symbol("opaque");
var optimized = Symbol("optimized");
var extraPrimitiveActivators = /* @__PURE__ */ new Map();
var extraPrimitiveProps = /* @__PURE__ */ new Map();
var __devExtractFunctionsAndComputedsNodes = true ? /* @__PURE__ */ new Set() : void 0;
var globalState = {
  isLoadingLocal: false,
  isLoadingRemote: false,
  isMerging: false,
  noDepWarn: false
};
function checkActivate(node) {
  var _a;
  const root = node.root;
  (_a = root.activate) === null || _a === void 0 ? void 0 : _a.call(root);
  if (root.computedChildrenNeedingActivation) {
    root.computedChildrenNeedingActivation.forEach(checkActivate);
    delete root.computedChildrenNeedingActivation;
  }
}
function getNode(obs) {
  return obs && obs[symbolGetNode];
}
function get(node, track) {
  updateTracking(node, track);
  return peek(node);
}
function peek(node) {
  checkActivate(node);
  return getNodeValue(node);
}
function setNodeValue(node, newValue) {
  var _a;
  const parentNode = (_a = node.parent) !== null && _a !== void 0 ? _a : node;
  const key = node.parent ? node.key : "_";
  const isDelete = newValue === symbolDelete;
  if (isDelete)
    newValue = void 0;
  const parentValue = node.parent ? ensureNodeValue(parentNode) : parentNode.root;
  const prevValue = parentValue[key];
  const isFunc = isFunction(newValue);
  newValue = !parentNode.isAssigning && isFunc ? newValue(prevValue) : isObject(newValue) && (newValue === null || newValue === void 0 ? void 0 : newValue[symbolGetNode]) ? newValue.peek() : newValue;
  try {
    parentNode.isSetting = (parentNode.isSetting || 0) + 1;
    if (isDelete) {
      delete parentValue[key];
    } else {
      parentValue[key] = newValue;
    }
  } finally {
    parentNode.isSetting--;
  }
  if (parentNode.root.locked && parentNode.root.set) {
    parentNode.root.set(parentNode.root._);
  }
  return { prevValue, newValue };
}
var arrNodeKeys = [];
function getNodeValue(node) {
  let count = 0;
  let n = node;
  while (isChildNodeValue(n)) {
    arrNodeKeys[count++] = n.key;
    n = n.parent;
  }
  let child = node.root._;
  for (let i = count - 1; child && i >= 0; i--) {
    const key = arrNodeKeys[i];
    child = key !== "size" && (child instanceof Map || child instanceof WeakMap) ? child.get(key) : child[key];
  }
  return child;
}
function getChildNode(node, key) {
  var _a;
  let child = (_a = node.children) === null || _a === void 0 ? void 0 : _a.get(key);
  if (!child) {
    child = {
      root: node.root,
      parent: node,
      key
    };
    if (!node.children) {
      node.children = /* @__PURE__ */ new Map();
    }
    node.children.set(key, child);
  }
  return child;
}
function ensureNodeValue(node) {
  let value = getNodeValue(node);
  if (!value) {
    if (isChildNodeValue(node)) {
      const parent = ensureNodeValue(node.parent);
      value = parent[node.key] = {};
    } else {
      value = node.root._ = {};
    }
  }
  return value;
}
function findIDKey(obj, node) {
  let idKey = isObject(obj) ? "id" in obj ? "id" : "key" in obj ? "key" : "_id" in obj ? "_id" : "__id" in obj ? "__id" : void 0 : void 0;
  if (!idKey && node.parent) {
    const keyExtractor = getNodeValue(node.parent)[node.key + "_keyExtractor"];
    if (keyExtractor && isFunction(keyExtractor)) {
      idKey = keyExtractor;
    }
  }
  return idKey;
}
function extractFunction(node, key, fnOrComputed, computedChildNode) {
  if (!node.functions) {
    node.functions = /* @__PURE__ */ new Map();
  }
  node.functions.set(key, fnOrComputed);
  if (computedChildNode) {
    computedChildNode.computedChildOfNode = getChildNode(node, key);
    if (!node.root.computedChildrenNeedingActivation) {
      node.root.computedChildrenNeedingActivation = [];
    }
    node.root.computedChildrenNeedingActivation.push(computedChildNode);
  }
}
function extractFunctionsAndComputeds(obj, node) {
  if (typeof __devExtractFunctionsAndComputedsNodes !== "undefined") {
    if (__devExtractFunctionsAndComputedsNodes.has(obj)) {
      console.error("[legend-state] Circular reference detected in object. You may want to use opaqueObject to stop traversing child nodes.", obj);
      return false;
    }
    __devExtractFunctionsAndComputedsNodes.add(obj);
  }
  for (const k in obj) {
    const v = obj[k];
    if (typeof v === "function") {
      extractFunction(node, k, v);
    } else if (typeof v == "object" && v !== null && v !== void 0) {
      const childNode = getNode(v);
      if (childNode === null || childNode === void 0 ? void 0 : childNode.isComputed) {
        extractFunction(node, k, v, childNode);
        delete obj[k];
      } else if (!v[symbolOpaque]) {
        extractFunctionsAndComputeds(obj[k], getChildNode(node, k));
      }
    }
  }
}
var timeout;
var numInBatch = 0;
var isRunningBatch = false;
var didDelayEndBatch = false;
var _afterBatch = [];
var _batchMap = /* @__PURE__ */ new Map();
function onActionTimeout() {
  if (_batchMap.size > 0) {
    if (true) {
      console.error("Forcibly completing observableBatcher because end() was never called. This may be due to an uncaught error between begin() and end().");
    }
    endBatch(
      /*force*/
      true
    );
  }
}
function isArraySubset(mainArr, subsetArr) {
  for (let i = 0; i < mainArr.length; i++) {
    if (mainArr[i] !== subsetArr[i]) {
      return false;
    }
  }
  return true;
}
function createPreviousHandlerInner(value, changes) {
  let clone = value ? JSON.parse(JSON.stringify(value)) : {};
  for (let i = 0; i < changes.length; i++) {
    const { path, prevAtPath } = changes[i];
    let o = clone;
    if (path.length > 0) {
      let i2;
      for (i2 = 0; i2 < path.length - 1; i2++) {
        o = o[path[i2]];
      }
      o[path[i2]] = prevAtPath;
    } else {
      clone = prevAtPath;
    }
  }
  return clone;
}
function createPreviousHandler(value, changes) {
  return function() {
    return createPreviousHandlerInner(value, changes);
  };
}
function notify(node, value, prev, level, whenOptimizedOnlyIf) {
  const changesInBatch = /* @__PURE__ */ new Map();
  computeChangesRecursive(
    changesInBatch,
    node,
    value,
    [],
    [],
    value,
    prev,
    /*immediate*/
    true,
    level,
    whenOptimizedOnlyIf
  );
  batchNotifyChanges(
    changesInBatch,
    /*immediate*/
    true
  );
  const existing = _batchMap.get(node);
  if (existing) {
    existing.value = value;
  } else {
    _batchMap.set(node, { value, prev, level, whenOptimizedOnlyIf });
  }
  if (numInBatch <= 0) {
    runBatch();
  }
}
function computeChangesAtNode(changesInBatch, node, value, path, pathTypes, valueAtPath, prevAtPath, immediate, level, whenOptimizedOnlyIf) {
  if (immediate ? node.listenersImmediate : node.listeners) {
    const change = {
      path,
      pathTypes,
      valueAtPath,
      prevAtPath
    };
    const changeInBatch = changesInBatch.get(node);
    if (changeInBatch && path.length > 0) {
      const { changes } = changeInBatch;
      if (!isArraySubset(changes[0].path, change.path)) {
        changes.push(change);
      }
    } else {
      changesInBatch.set(node, {
        level,
        value,
        whenOptimizedOnlyIf,
        changes: [change]
      });
    }
  }
}
function computeChangesRecursive(changesInBatch, node, value, path, pathTypes, valueAtPath, prevAtPath, immediate, level, whenOptimizedOnlyIf) {
  computeChangesAtNode(changesInBatch, node, value, path, pathTypes, valueAtPath, prevAtPath, immediate, level, whenOptimizedOnlyIf);
  if (node.linkedFromNodes) {
    for (const linkedFromNode of node.linkedFromNodes) {
      computeChangesAtNode(changesInBatch, linkedFromNode, value, path, pathTypes, valueAtPath, prevAtPath, immediate, level, whenOptimizedOnlyIf);
    }
  }
  if (node.parent) {
    const parent = node.parent;
    if (parent) {
      const parentValue = getNodeValue(parent);
      computeChangesRecursive(changesInBatch, parent, parentValue, [node.key].concat(path), [isArray(value) ? "array" : "object"].concat(pathTypes), valueAtPath, prevAtPath, immediate, level + 1, whenOptimizedOnlyIf);
    }
  }
}
function batchNotifyChanges(changesInBatch, immediate) {
  const listenersNotified = /* @__PURE__ */ new Set();
  changesInBatch.forEach(({ changes, level, value, whenOptimizedOnlyIf }, node) => {
    const listeners = immediate ? node.listenersImmediate : node.listeners;
    if (listeners) {
      let listenerParams;
      const arr = Array.from(listeners);
      for (let i = 0; i < arr.length; i++) {
        const listenerFn = arr[i];
        const { track, noArgs, listener } = listenerFn;
        if (!listenersNotified.has(listener)) {
          const ok = track === true || track === "shallow" ? level <= 0 : track === optimized ? whenOptimizedOnlyIf && level <= 0 : true;
          if (ok) {
            if (!noArgs && !listenerParams) {
              listenerParams = {
                value,
                getPrevious: createPreviousHandler(value, changes),
                changes
              };
            }
            if (!track) {
              listenersNotified.add(listener);
            }
            listener(listenerParams);
          }
        }
      }
    }
  });
}
function runBatch() {
  const map = _batchMap;
  _batchMap = /* @__PURE__ */ new Map();
  const changesInBatch = /* @__PURE__ */ new Map();
  map.forEach(({ value, prev, level, whenOptimizedOnlyIf }, node) => {
    computeChangesRecursive(changesInBatch, node, value, [], [], value, prev, false, level, whenOptimizedOnlyIf);
  });
  batchNotifyChanges(changesInBatch, false);
}
function batch(fn, onComplete) {
  if (onComplete) {
    _afterBatch.push(onComplete);
  }
  beginBatch();
  try {
    fn();
  } finally {
    endBatch();
  }
}
function beginBatch() {
  numInBatch++;
  if (!timeout) {
    timeout = setTimeout(onActionTimeout, 0);
  }
}
function endBatch(force) {
  numInBatch--;
  if (numInBatch <= 0 || force) {
    if (isRunningBatch) {
      didDelayEndBatch = true;
    } else {
      if (timeout) {
        clearTimeout(timeout);
        timeout = void 0;
      }
      numInBatch = 0;
      const after = _afterBatch;
      if (after.length) {
        _afterBatch = [];
      }
      isRunningBatch = true;
      runBatch();
      isRunningBatch = false;
      for (let i = 0; i < after.length; i++) {
        after[i]();
      }
      if (didDelayEndBatch) {
        didDelayEndBatch = false;
        endBatch(true);
      }
    }
  }
}
function afterBatch(fn) {
  if (numInBatch > 0) {
    _afterBatch.push(fn);
  } else {
    fn();
  }
}
function onChange(node, callback, options = {}) {
  const { initial, immediate, noArgs } = options;
  let { trackingType } = options;
  if (trackingType === "optimize") {
    if (!globalState.noDepWarn) {
      console.warn('[legend-state]: "optimize" prop is deprecated and will be removed in version 2.0. Please import { optimize } from "@legendapp/state" and use that instead.');
    }
    trackingType = optimized;
  }
  let listeners = immediate ? node.listenersImmediate : node.listeners;
  if (!listeners) {
    listeners = /* @__PURE__ */ new Set();
    if (immediate) {
      node.listenersImmediate = listeners;
    } else {
      node.listeners = listeners;
    }
  }
  checkActivate(node);
  const listener = {
    listener: callback,
    track: trackingType,
    noArgs
  };
  listeners.add(listener);
  let parent = node.parent;
  while (parent && !parent.descendantHasListener) {
    parent.descendantHasListener = true;
    parent = parent.parent;
  }
  if (initial) {
    const value = getNodeValue(node);
    callback({
      value,
      changes: [
        {
          path: [],
          pathTypes: [],
          prevAtPath: value,
          valueAtPath: value
        }
      ],
      getPrevious: () => void 0
    });
  }
  return () => listeners.delete(listener);
}
var ArrayModifiers = /* @__PURE__ */ new Set([
  "copyWithin",
  "fill",
  "from",
  "pop",
  "push",
  "reverse",
  "shift",
  "sort",
  "splice",
  "unshift"
]);
var ArrayLoopers = /* @__PURE__ */ new Set([
  "every",
  "filter",
  "find",
  "findIndex",
  "forEach",
  "includes",
  "join",
  "map",
  "some"
]);
var ArrayLoopersReturn = /* @__PURE__ */ new Set(["filter", "find"]);
var observableProperties = /* @__PURE__ */ new Map();
var observableFns = /* @__PURE__ */ new Map([
  ["get", get],
  ["set", set],
  ["peek", peek],
  ["onChange", onChange],
  ["assign", assign],
  ["delete", deleteFn],
  ["toggle", toggle]
]);
if (true) {
  __devUpdateNodes = /* @__PURE__ */ new Set();
}
var __devUpdateNodes;
function collectionSetter(node, target, prop, ...args) {
  var _a;
  const prevValue = isArray(target) && target.slice() || target;
  const ret = target[prop].apply(target, args);
  if (node) {
    const hasParent = isChildNodeValue(node);
    const key = hasParent ? node.key : "_";
    const parentValue = hasParent ? getNodeValue(node.parent) : node.root;
    parentValue[key] = prevValue;
    setKey((_a = node.parent) !== null && _a !== void 0 ? _a : node, key, target);
  }
  return ret;
}
function updateNodes(parent, obj, prevValue) {
  if (typeof __devUpdateNodes !== "undefined" && isObject(obj)) {
    if (__devUpdateNodes.has(obj)) {
      console.error("[legend-state] Circular reference detected in object. You may want to use opaqueObject to stop traversing child nodes.", obj);
      return false;
    }
    __devUpdateNodes.add(obj);
  }
  if (isObject(obj) && obj[symbolOpaque] || isObject(prevValue) && prevValue[symbolOpaque]) {
    const isDiff = obj !== prevValue;
    if (isDiff) {
      if (parent.listeners || parent.listenersImmediate) {
        notify(parent, obj, prevValue, 0);
      }
    }
    if (typeof __devUpdateNodes !== "undefined" && obj !== void 0) {
      __devUpdateNodes.delete(obj);
    }
    return isDiff;
  }
  const isArr = isArray(obj);
  let prevChildrenById;
  let moved;
  const isMap = obj instanceof Map;
  const keys = obj ? isMap ? Array.from(obj.keys()) : Object.keys(obj) : [];
  const keysPrev = prevValue ? isMap ? Array.from(prevValue.keys()) : Object.keys(prevValue) : [];
  let idField;
  let isIdFieldFunction;
  let hasADiff = false;
  let retValue;
  if (isArr && isArray(prevValue)) {
    if (prevValue.length > 0) {
      const firstPrevValue = prevValue[0];
      if (firstPrevValue !== void 0) {
        idField = findIDKey(firstPrevValue, parent);
        if (idField) {
          isIdFieldFunction = isFunction(idField);
          prevChildrenById = /* @__PURE__ */ new Map();
          moved = [];
          const keysSeen = true ? /* @__PURE__ */ new Set() : void 0;
          if (parent.children) {
            for (let i = 0; i < prevValue.length; i++) {
              const p = prevValue[i];
              if (p) {
                const child = parent.children.get(i + "");
                if (child) {
                  const key = isIdFieldFunction ? idField(p) : p[idField];
                  if (true) {
                    if (keysSeen.has(key)) {
                      console.warn(`[legend-state] Warning: Multiple elements in array have the same ID. Key field: ${idField}, Array:`, prevValue);
                    }
                    keysSeen.add(key);
                  }
                  prevChildrenById.set(key, child);
                }
              }
            }
          }
        }
      }
    }
  } else if (prevValue && (!obj || isObject(obj))) {
    const lengthPrev = keysPrev.length;
    for (let i = 0; i < lengthPrev; i++) {
      const key = keysPrev[i];
      if (!keys.includes(key)) {
        hasADiff = true;
        const child = getChildNode(parent, key);
        const prev = isMap ? prevValue.get(key) : prevValue[key];
        if (prev !== void 0) {
          if (!isPrimitive(prev)) {
            updateNodes(child, void 0, prev);
          }
          if (child.listeners || child.listenersImmediate) {
            notify(child, void 0, prev, 0);
          }
        }
      }
    }
  }
  if (obj && !isPrimitive(obj)) {
    const length = keys.length;
    hasADiff = hasADiff || (keys === null || keys === void 0 ? void 0 : keys.length) !== (keysPrev === null || keysPrev === void 0 ? void 0 : keysPrev.length);
    const isArrDiff = hasADiff;
    let didMove = false;
    if (parent.descendantHasListener || !hasADiff) {
      for (let i = 0; i < length; i++) {
        const key = keys[i];
        const value = isMap ? obj.get(key) : obj[key];
        const prev = isMap ? prevValue === null || prevValue === void 0 ? void 0 : prevValue.get(key) : prevValue === null || prevValue === void 0 ? void 0 : prevValue[key];
        let isDiff = value !== prev;
        if (isDiff) {
          const id = idField && value ? isIdFieldFunction ? idField(value) : value[idField] : void 0;
          let child = getChildNode(parent, key);
          if (isArr && id !== void 0) {
            const prevChild = id !== void 0 ? prevChildrenById === null || prevChildrenById === void 0 ? void 0 : prevChildrenById.get(id) : void 0;
            if (!prevChild) {
              isDiff = false;
              hasADiff = true;
            } else if (prevChild !== void 0 && prevChild.key !== key) {
              const valuePrevChild = prevValue[prevChild.key];
              if (isArrDiff) {
                child = prevChild;
                parent.children.delete(child.key);
                child.key = key;
                moved.push([key, child]);
              }
              didMove = true;
              isDiff = valuePrevChild !== value;
            }
          }
          if (isDiff) {
            if (isPrimitive(value)) {
              hasADiff = true;
            } else {
              const updatedNodes = (!hasADiff || !!child.descendantHasListener) && updateNodes(child, value, prev);
              hasADiff = hasADiff || updatedNodes;
            }
          }
          if (isDiff || !isArrDiff) {
            if (child.listeners || child.listenersImmediate) {
              notify(child, value, prev, 0, !isArrDiff);
            }
          }
        }
      }
      if (moved) {
        for (let i = 0; i < moved.length; i++) {
          const [key, child] = moved[i];
          parent.children.set(key, child);
        }
      }
    }
    retValue = hasADiff || didMove;
  } else if (prevValue !== void 0) {
    retValue = true;
  }
  if (typeof __devUpdateNodes !== "undefined" && obj !== void 0) {
    __devUpdateNodes.delete(obj);
  }
  return retValue !== null && retValue !== void 0 ? retValue : false;
}
function getProxy(node, p) {
  if (p !== void 0)
    node = getChildNode(node, p);
  return node.proxy || (node.proxy = new Proxy(node, proxyHandler));
}
var proxyHandler = {
  get(node, p, receiver) {
    var _a;
    if (p === symbolToPrimitive) {
      throw new Error(true ? "[legend-state] observable should not be used as a primitive. You may have forgotten to use .get() or .peek() to get the value of the observable." : "[legend-state] observable is not a primitive.");
    }
    if (p === symbolGetNode) {
      return node;
    }
    if (node.linkedToNode && p !== "onChange") {
      return proxyHandler.get(node.linkedToNode, p, receiver);
    }
    const value = peek(node);
    if (value instanceof Map || value instanceof WeakMap || value instanceof Set || value instanceof WeakSet) {
      const ret = handlerMapSet(node, p, value);
      if (ret !== void 0) {
        return ret;
      }
    }
    const fn = observableFns.get(p);
    if (fn) {
      return function(a, b, c) {
        const l = arguments.length;
        switch (l) {
          case 0:
            return fn(node);
          case 1:
            return fn(node, a);
          case 2:
            return fn(node, a, b);
          default:
            return fn(node, a, b, c);
        }
      };
    }
    if (node.isComputed) {
      if (node.proxyFn && !fn) {
        return node.proxyFn(p);
      } else {
        checkActivate(node);
      }
    }
    const property = observableProperties.get(p);
    if (property) {
      return property.get(node);
    }
    const isValuePrimitive = isPrimitive(value);
    if (value === void 0 || value === null || isValuePrimitive) {
      if (extraPrimitiveProps.size && (node.isActivatedPrimitive || extraPrimitiveActivators.has(p))) {
        node.isActivatedPrimitive = true;
        const vPrim = extraPrimitiveProps.get(p);
        if (vPrim !== void 0) {
          return isFunction(vPrim) ? vPrim(getProxy(node)) : vPrim;
        }
      }
    }
    const vProp = value === null || value === void 0 ? void 0 : value[p];
    if (isObject(value) && value[symbolOpaque]) {
      return vProp;
    }
    if (isFunction(vProp)) {
      if (isArray(value)) {
        if (ArrayModifiers.has(p)) {
          return (...args) => collectionSetter(node, value, p, ...args);
        } else if (ArrayLoopers.has(p)) {
          updateTracking(node);
          return function(cbOrig, thisArg) {
            function cbWrapped(_, index, array) {
              return cbOrig(getProxy(node, index + ""), index, array);
            }
            if (ArrayLoopersReturn.has(p)) {
              const isFind = p === "find";
              const out = [];
              for (let i = 0; i < value.length; i++) {
                if (cbWrapped(value[i], i, value)) {
                  const proxy2 = getProxy(node, i + "");
                  if (isFind) {
                    return proxy2;
                  } else {
                    out.push(proxy2);
                  }
                }
              }
              return isFind ? void 0 : out;
            } else {
              return value[p](cbWrapped, thisArg);
            }
          };
        }
      }
      return vProp.bind(value);
    }
    if (isPrimitive(vProp)) {
      if (isArray(value) && p === "length") {
        updateTracking(node, true);
        return vProp;
      }
    }
    const fnOrComputed = (_a = node.functions) === null || _a === void 0 ? void 0 : _a.get(p);
    if (fnOrComputed) {
      return fnOrComputed;
    }
    return getProxy(node, p);
  },
  // Forward all proxy properties to the target's value
  getPrototypeOf(node) {
    const value = getNodeValue(node);
    return value !== null && typeof value === "object" ? Reflect.getPrototypeOf(value) : null;
  },
  ownKeys(node) {
    const value = getNodeValue(node);
    if (isPrimitive(value))
      return [];
    const keys = value ? Reflect.ownKeys(value) : [];
    updateTracking(node, true);
    if (isArray(value) && keys[keys.length - 1] === "length") {
      keys.splice(keys.length - 1, 1);
    }
    return keys;
  },
  getOwnPropertyDescriptor(node, prop) {
    const value = getNodeValue(node);
    return !isPrimitive(value) ? Reflect.getOwnPropertyDescriptor(value, prop) : void 0;
  },
  set(node, prop, value) {
    if (node.isSetting) {
      return Reflect.set(node, prop, value);
    }
    if (node.isAssigning) {
      setKey(node, prop, value);
      return true;
    }
    const property = observableProperties.get(prop);
    if (property) {
      property.set(node, value);
      return true;
    }
    if (true) {
      console.warn("[legend-state]: Error: Cannot set a value directly:", prop, value);
    }
    return false;
  },
  deleteProperty(node, prop) {
    if (node.isSetting) {
      return Reflect.deleteProperty(node, prop);
    } else {
      if (true) {
        console.warn("[legend-state]: Error: Cannot delete a value directly:", prop);
      }
      return false;
    }
  },
  has(node, prop) {
    const value = getNodeValue(node);
    return Reflect.has(value, prop);
  }
};
function set(node, newValue) {
  if (isPromise(newValue)) {
    newValue.then((v) => set(node, v)).catch((error) => set(node, { error }));
  } else if (node.parent) {
    return setKey(node.parent, node.key, newValue);
  } else {
    return setKey(node, "_", newValue);
  }
}
function toggle(node) {
  const value = getNodeValue(node);
  if (value === void 0 || isBoolean(value)) {
    set(node, !value);
    return !value;
  } else if (true) {
    throw new Error("[legend-state] Cannot toggle a non-boolean value");
  }
}
function setKey(node, key, newValue, level) {
  if (true) {
    if (typeof HTMLElement !== "undefined" && newValue instanceof HTMLElement) {
      console.warn(`[legend-state] Set an HTMLElement into state. You probably don't want to do that.`);
    }
  }
  if (node.root.locked && !node.root.set) {
    if (globalState.isMerging) {
      return;
    } else {
      throw new Error(true ? "[legend-state] Cannot modify an observable while it is locked. Please make sure that you unlock the observable before making changes." : "[legend-state] Modified locked observable");
    }
  }
  const isRoot = !node.parent && key === "_";
  const childNode = isRoot ? node : getChildNode(node, key);
  const { newValue: savedValue, prevValue } = setNodeValue(childNode, newValue);
  const isFunc = isFunction(newValue);
  const isPrim = isPrimitive(savedValue) || savedValue instanceof Date;
  if (savedValue !== prevValue) {
    updateNodesAndNotify(node, savedValue, prevValue, childNode, isPrim, isRoot, level);
  }
  return isFunc ? savedValue : isRoot ? getProxy(node) : getProxy(node, key);
}
function assign(node, value) {
  const proxy2 = getProxy(node);
  beginBatch();
  if (isPrimitive(node.root._)) {
    node.root._ = {};
  }
  node.isAssigning = (node.isAssigning || 0) + 1;
  try {
    Object.assign(proxy2, value);
  } finally {
    node.isAssigning--;
  }
  endBatch();
  return proxy2;
}
function deleteFn(node, key) {
  if (key === void 0 && isChildNodeValue(node)) {
    key = node.key;
    node = node.parent;
  }
  setKey(
    node,
    key !== null && key !== void 0 ? key : "_",
    symbolDelete,
    /*level*/
    -1
  );
}
function handlerMapSet(node, p, value) {
  const vProp = value === null || value === void 0 ? void 0 : value[p];
  if (p === "size") {
    return getProxy(node, p);
  } else if (isFunction(vProp)) {
    return function(a, b, c) {
      const l = arguments.length;
      const valueMap = value;
      if (p === "get") {
        if (l > 0 && typeof a !== "boolean" && a !== optimized) {
          return getProxy(node, a);
        }
      } else if (p === "set") {
        if (l === 2) {
          const prev = valueMap.get(a);
          const ret = valueMap.set(a, b);
          if (prev !== b) {
            updateNodesAndNotify(getChildNode(node, a), b, prev);
          }
          return ret;
        }
      } else if (p === "delete") {
        if (l > 0) {
          const prev = value.get ? valueMap.get(a) : a;
          const ret = value.delete(a);
          if (ret) {
            updateNodesAndNotify(getChildNode(node, a), void 0, prev);
          }
          return ret;
        }
      } else if (p === "clear") {
        const prev = new Map(valueMap);
        const size = valueMap.size;
        valueMap.clear();
        if (size) {
          updateNodesAndNotify(node, value, prev);
        }
        return;
      } else if (p === "add") {
        const prev = new Set(value);
        const ret = value.add(a);
        if (!value.has(p)) {
          notify(node, ret, prev, 0);
        }
        return ret;
      }
      const fn = observableFns.get(p);
      if (fn) {
        switch (l) {
          case 0:
            return fn(node);
          case 1:
            return fn(node, a);
          case 2:
            return fn(node, a, b);
          default:
            return fn(node, a, b, c);
        }
      } else {
        return value[p](a, b);
      }
    };
  }
}
function updateNodesAndNotify(node, newValue, prevValue, childNode, isPrim, isRoot, level) {
  if (!childNode)
    childNode = node;
  beginBatch();
  let hasADiff = isPrim;
  let whenOptimizedOnlyIf = false;
  if (!isPrim || prevValue && !isPrimitive(prevValue)) {
    if (typeof __devUpdateNodes !== "undefined") {
      __devUpdateNodes.clear();
    }
    hasADiff = updateNodes(childNode, newValue, prevValue);
    if (isArray(newValue)) {
      whenOptimizedOnlyIf = (newValue === null || newValue === void 0 ? void 0 : newValue.length) !== (prevValue === null || prevValue === void 0 ? void 0 : prevValue.length);
    }
  }
  if (isPrim || !newValue || isEmpty(newValue) && !isEmpty(prevValue) ? newValue !== prevValue : hasADiff) {
    notify(isPrim && isRoot ? node : childNode, newValue, prevValue, (level !== null && level !== void 0 ? level : prevValue === void 0) ? -1 : hasADiff ? 0 : 1, whenOptimizedOnlyIf);
  }
  endBatch();
}
function isObservable(obs) {
  return obs && !!obs[symbolGetNode];
}
function isEvent(obs) {
  var _a;
  return obs && ((_a = obs[symbolGetNode]) === null || _a === void 0 ? void 0 : _a.isEvent);
}
function computeSelector(selector, e, retainObservable) {
  let c = selector;
  if (isFunction(c)) {
    c = e ? c(e) : c();
  }
  return isObservable(c) && !retainObservable ? c.get() : c;
}
function getObservableIndex(obs) {
  const node = getNode(obs);
  const n = +node.key;
  return n - n < 1 ? +n : -1;
}
function opaqueObject(value) {
  if (value) {
    value[symbolOpaque] = true;
  }
  return value;
}
function lockObservable(obs, value) {
  var _a;
  const root = (_a = getNode(obs)) === null || _a === void 0 ? void 0 : _a.root;
  if (root) {
    root.locked = value;
  }
}
function setAtPath(obj, path, pathTypes, value, fullObj, restore) {
  let o = obj;
  let oFull = fullObj;
  if (path.length > 0) {
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      if (i === path.length - 1) {
        if (o[p] !== value) {
          o[p] = value;
        }
      } else if (o[p] === symbolDelete) {
        if (oFull) {
          o[p] = oFull[p];
          restore === null || restore === void 0 ? void 0 : restore(path.slice(0, i + 1), o[p]);
        }
        break;
      } else if (o[p] === void 0 || o[p] === null) {
        o[p] = pathTypes[i] === "array" ? [] : {};
      }
      o = o[p];
      if (oFull) {
        oFull = oFull[p];
      }
    }
  } else {
    obj = value;
  }
  return obj;
}
function setInObservableAtPath(obs, path, value, mode) {
  let o = obs;
  let v = value;
  for (let i = 0; i < path.length; i++) {
    const p = path[i];
    o = o[p];
    v = v[p];
  }
  if (v === symbolDelete) {
    o.delete();
  } else if (mode === "assign" && o.assign && isObject(o.peek())) {
    o.assign(v);
  } else {
    o.set(v);
  }
}
function mergeIntoObservable(target, ...sources) {
  beginBatch();
  globalState.isMerging = true;
  const value = _mergeIntoObservable(target, ...sources);
  globalState.isMerging = false;
  endBatch();
  return value;
}
function _mergeIntoObservable(target, ...sources) {
  var _a;
  if (!sources.length)
    return target;
  for (let u = 0; u < sources.length; u++) {
    const source = sources[u];
    const needsSet = isObservable(target);
    const targetValue = needsSet ? target.peek() : target;
    const isTargetArr = isArray(targetValue);
    const isTargetObj = !isTargetArr && isObject(targetValue);
    if (isTargetObj && isObject(source) && !isEmpty(targetValue) || isTargetArr && isArray(source) && targetValue.length > 0) {
      for (const key in source) {
        const sourceValue = source[key];
        if (sourceValue === symbolDelete) {
          needsSet && ((_a = target[key]) === null || _a === void 0 ? void 0 : _a.delete) ? target[key].delete() : delete target[key];
        } else {
          const isObj = isObject(sourceValue);
          const isArr = !isObj && isArray(sourceValue);
          const targetChild = target[key];
          if ((isObj || isArr) && targetChild && (needsSet || !isEmpty(targetChild))) {
            if (!needsSet && (!targetChild || (isObj ? !isObject(targetChild) : !isArray(targetChild)))) {
              target[key] = sourceValue;
            } else {
              _mergeIntoObservable(targetChild, sourceValue);
            }
          } else {
            needsSet ? targetChild.set(sourceValue) : target[key] = sourceValue;
          }
        }
      }
    } else if (source !== void 0) {
      needsSet ? target.set(source) : target = source;
    }
  }
  return target;
}
function constructObjectWithPath(path, value, pathTypes) {
  let out;
  if (path.length > 0) {
    let o = out = {};
    for (let i = 0; i < path.length; i++) {
      const p = path[i];
      o[p] = i === path.length - 1 ? value : pathTypes[i] === "array" ? [] : {};
      o = o[p];
    }
  } else {
    out = value;
  }
  return out;
}
function deconstructObjectWithPath(path, value) {
  let o = value;
  for (let i = 0; i < path.length; i++) {
    const p = path[i];
    o = o[p];
  }
  return o;
}
function isObservableValueReady(value) {
  return !!value && (!isObject(value) && !isArray(value) || !isEmpty(value));
}
function setSilently(obs, newValue) {
  const node = getNode(obs);
  return setNodeValue(node, newValue).newValue;
}
var fns = ["get", "set", "peek", "onChange", "toggle"];
function ObservablePrimitiveClass(node) {
  this._node = node;
  for (let i = 0; i < fns.length; i++) {
    const key = fns[i];
    this[key] = this[key].bind(this);
  }
}
function proto(key, fn) {
  ObservablePrimitiveClass.prototype[key] = function(...args) {
    return fn.call(this, this._node, ...args);
  };
}
proto("peek", peek);
proto("get", get);
proto("set", set);
proto("onChange", onChange);
Object.defineProperty(ObservablePrimitiveClass.prototype, symbolGetNode, {
  configurable: true,
  get() {
    return this._node;
  }
});
ObservablePrimitiveClass.prototype.toggle = function() {
  const value = this.peek();
  if (value === void 0 || isBoolean(value)) {
    this.set(!value);
  } else if (true) {
    throw new Error("[legend-state] Cannot toggle a non-boolean value");
  }
  return !value;
};
ObservablePrimitiveClass.prototype.delete = function() {
  this.set(void 0);
  return this;
};
function createObservable(value, makePrimitive) {
  const valueIsPromise = isPromise(value);
  const root = {
    _: valueIsPromise ? void 0 : value
  };
  const node = {
    root
  };
  const prim = makePrimitive || isActualPrimitive(value);
  const obs = prim ? new ObservablePrimitiveClass(node) : getProxy(node);
  if (valueIsPromise) {
    value.catch((error) => {
      obs.set({ error });
    });
    value.then((value2) => {
      obs.set(value2);
    });
  } else if (!prim) {
    if (true) {
      __devExtractFunctionsAndComputedsNodes.clear();
    }
    if (value) {
      extractFunctionsAndComputeds(value, node);
    }
  }
  return obs;
}
function observable(value) {
  return createObservable(value);
}
function observablePrimitive(value) {
  return createObservable(
    value,
    /*makePrimitive*/
    true
  );
}
function setupTracking(nodes, update, noArgs, immediate) {
  let listeners = [];
  nodes === null || nodes === void 0 ? void 0 : nodes.forEach((tracked) => {
    const { node, track } = tracked;
    listeners.push(onChange(node, update, { trackingType: track, immediate, noArgs }));
  });
  return () => {
    if (listeners) {
      for (let i = 0; i < listeners.length; i++) {
        listeners[i]();
      }
      listeners = void 0;
    }
  };
}
function trackSelector(selector, update, observeEvent, observeOptions, createResubscribe, inRender) {
  var _a;
  let nodes;
  let value;
  let dispose;
  let tracker;
  let resubscribe;
  let updateFn = update;
  if (isObservable(selector)) {
    value = selector.peek();
    dispose = selector.onChange(update);
    resubscribe = createResubscribe ? selector.onChange(update) : void 0;
  } else {
    beginTracking(inRender);
    value = selector ? computeSelector(selector, observeEvent, observeOptions === null || observeOptions === void 0 ? void 0 : observeOptions.retainObservable) : selector;
    tracker = tracking.current;
    nodes = tracker.nodes;
    endTracking(inRender);
    if (tracker && nodes) {
      (_a = tracker.traceListeners) === null || _a === void 0 ? void 0 : _a.call(tracker, nodes);
      if (tracker.traceUpdates) {
        updateFn = tracker.traceUpdates(update);
      }
      tracker.traceListeners = void 0;
      tracker.traceUpdates = void 0;
    }
  }
  if (!(observeEvent === null || observeEvent === void 0 ? void 0 : observeEvent.cancel)) {
    dispose = setupTracking(nodes, updateFn, false, observeOptions === null || observeOptions === void 0 ? void 0 : observeOptions.immediate);
    resubscribe = createResubscribe ? () => setupTracking(nodes, updateFn) : void 0;
  }
  return { value, dispose, resubscribe };
}
function observe(selectorOrRun, reactionOrOptions, options) {
  let reaction;
  if (isFunction(reactionOrOptions)) {
    reaction = reactionOrOptions;
  } else {
    options = reactionOrOptions;
  }
  let dispose;
  let isFirstRun = true;
  const e = { num: 0 };
  const update = function() {
    if (e.onCleanup) {
      e.onCleanup();
      e.onCleanup = void 0;
    }
    beginBatch();
    delete e.value;
    dispose === null || dispose === void 0 ? void 0 : dispose();
    const { dispose: _dispose, value } = trackSelector(selectorOrRun, update, e, options);
    dispose = _dispose;
    e.value = value;
    if (e.onCleanupReaction) {
      e.onCleanupReaction();
      e.onCleanupReaction = void 0;
    }
    if (reaction && (e.num > 0 || !isEvent(selectorOrRun)) && (isFirstRun || e.previous !== e.value)) {
      reaction(e);
    }
    e.previous = e.value;
    e.num++;
    endBatch();
    isFirstRun = false;
  };
  update();
  return () => {
    var _a, _b;
    (_a = e.onCleanup) === null || _a === void 0 ? void 0 : _a.call(e);
    e.onCleanup = void 0;
    (_b = e.onCleanupReaction) === null || _b === void 0 ? void 0 : _b.call(e);
    e.onCleanupReaction = void 0;
    dispose === null || dispose === void 0 ? void 0 : dispose();
  };
}
function computed(compute, set$1) {
  const obs = observable();
  lockObservable(obs, true);
  const node = getNode(obs);
  node.isComputed = true;
  let isSetAfterActivated = false;
  const setInner = function(val) {
    const prevNode = node.linkedToNode;
    if (prevNode) {
      prevNode.linkedFromNodes.delete(node);
      node.linkedToNode = void 0;
    }
    const childNode = node.computedChildOfNode;
    if (isObservable(val)) {
      const linkedNode = getNode(val);
      node.linkedToNode = linkedNode;
      if (!linkedNode.linkedFromNodes) {
        linkedNode.linkedFromNodes = /* @__PURE__ */ new Set();
      }
      linkedNode.linkedFromNodes.add(node);
      if (node.computedChildOfNode) {
        onChange(linkedNode, ({ value }) => {
          setNodeValue(node.computedChildOfNode, value);
        }, { initial: true });
      }
      if (prevNode) {
        const value = getNodeValue(linkedNode);
        const prevValue = getNodeValue(prevNode);
        notify(node, value, prevValue, 0);
      }
    } else if (val !== obs.peek()) {
      lockObservable(obs, false);
      const setter = isSetAfterActivated ? set : setNodeValue;
      setter(node, val);
      if (childNode) {
        let didUnlock = false;
        if (childNode.root.locked) {
          childNode.root.locked = false;
          didUnlock = true;
        }
        setter(childNode, val);
        if (didUnlock) {
          childNode.root.locked = true;
        }
      }
      lockObservable(obs, true);
    } else if (childNode) {
      setNodeValue(childNode, val);
    }
    isSetAfterActivated = true;
  };
  node.root.activate = () => {
    node.root.activate = void 0;
    observe(compute, ({ value }) => {
      if (isPromise(value)) {
        value.then((v) => setInner(v));
      } else {
        setInner(value);
      }
    }, { immediate: true, retainObservable: true });
  };
  if (set$1) {
    node.root.set = (value) => {
      batch(() => set$1(value));
    };
  }
  return obs;
}
function configureLegendState({ observableFunctions, observableProperties: observableProperties$1 }) {
  if (observableFunctions) {
    for (const key in observableFunctions) {
      const fn = observableFunctions[key];
      observableFns.set(key, fn);
      ObservablePrimitiveClass.prototype[key] = function(...args) {
        return fn.call(this, this._node, ...args);
      };
    }
  }
  if (observableProperties$1) {
    for (const key in observableProperties$1) {
      const fns2 = observableProperties$1[key];
      observableProperties.set(key, fns2);
      Object.defineProperty(ObservablePrimitiveClass.prototype, key, {
        configurable: true,
        get() {
          return fns2.get.call(this, this._node);
        },
        set(value) {
          return fns2.set.call(this, this._node, value);
        }
      });
    }
  }
}
function event() {
  const obs = observable(0);
  const node = getNode(obs);
  node.isEvent = true;
  return {
    fire: function() {
      obs.set((v) => v + 1);
    },
    on: function(cb) {
      return obs.onChange(cb);
    },
    get: function() {
      return obs.get();
    },
    // @ts-expect-error eslint doesn't like adding symbols to the object but this does work
    [symbolGetNode]: node
  };
}
function proxy(get2, set2) {
  const obs = observable({});
  lockObservable(obs, true);
  const mapTargets = /* @__PURE__ */ new Map();
  const node = getNode(obs);
  node.isComputed = true;
  node.proxyFn = (key) => {
    let target = mapTargets.get(key);
    if (!target) {
      target = computed(() => get2(key), set2 ? (value) => set2(key, value) : void 0);
      mapTargets.set(key, target);
      extractFunction(node, key, target, getNode(target));
      if (node.computedChildOfNode) {
        onChange(getNode(target), ({ value, getPrevious }) => {
          const previous = getPrevious();
          setNodeValue(node.computedChildOfNode, node.root._);
          notify(getChildNode(node, key), value, previous, 0);
        });
      }
    }
    return target;
  };
  return obs;
}
function _when(predicate, effect, checkReady) {
  let value;
  function run(e) {
    const ret = computeSelector(predicate);
    if (checkReady ? isObservableValueReady(ret) : ret) {
      value = ret;
      effect === null || effect === void 0 ? void 0 : effect(ret);
      e.cancel = true;
    }
  }
  observe(run);
  if (value !== void 0) {
    return Promise.resolve(value);
  } else {
    const promise = new Promise((resolve) => {
      if (effect) {
        const originalEffect = effect;
        effect = (value2) => {
          const effectValue = originalEffect(value2);
          resolve(effectValue);
        };
      } else {
        effect = resolve;
      }
    });
    return promise;
  }
}
function when(predicate, effect) {
  return _when(predicate, effect, false);
}
function whenReady(predicate, effect) {
  return _when(predicate, effect, true);
}
var internal = {
  ensureNodeValue,
  findIDKey,
  get,
  getNode,
  getProxy,
  globalState,
  optimized,
  peek,
  set,
  setAtPath,
  setNodeValue,
  symbolDelete
};

export {
  isArray,
  isString,
  isObject,
  isFunction,
  isPrimitive,
  isSymbol,
  isBoolean,
  isPromise,
  isEmpty,
  tracking,
  beginTracking,
  endTracking,
  updateTracking,
  symbolDelete,
  optimized,
  extraPrimitiveActivators,
  extraPrimitiveProps,
  checkActivate,
  getNode,
  getNodeValue,
  findIDKey,
  batch,
  beginBatch,
  endBatch,
  afterBatch,
  isObservable,
  computeSelector,
  getObservableIndex,
  opaqueObject,
  lockObservable,
  setAtPath,
  setInObservableAtPath,
  mergeIntoObservable,
  constructObjectWithPath,
  deconstructObjectWithPath,
  isObservableValueReady,
  setSilently,
  ObservablePrimitiveClass,
  observable,
  observablePrimitive,
  setupTracking,
  trackSelector,
  observe,
  computed,
  configureLegendState,
  event,
  proxy,
  when,
  whenReady,
  internal
};
//# sourceMappingURL=chunk-OUCLKSCB.js.map
