import {
  computeSelector,
  configureLegendState,
  internal,
  isEmpty,
  isFunction,
  isObservable,
  isPrimitive,
  isPromise,
  trackSelector,
  tracking
} from "./chunk-OUCLKSCB.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/@legendapp/state/react.mjs
var import_react = __toESM(require_react(), 1);
var shim = { exports: {} };
var useSyncExternalStoreShim_development = {};
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development)
    return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React = import_react.default;
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useState = React.useState, useEffect2 = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect2(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}
(function(module) {
  if (false) {
    module.exports = requireUseSyncExternalStoreShim_production_min();
  } else {
    module.exports = requireUseSyncExternalStoreShim_development();
  }
})(shim);
function createSelectorFunctions(options) {
  let version = 0;
  let notify;
  let dispose;
  let resubscribe;
  let _selector;
  let prev;
  const _update = ({ value }) => {
    let changed = options === null || options === void 0 ? void 0 : options.skipCheck;
    if (!changed) {
      const newValue = computeSelector(_selector);
      if (newValue !== prev || !isPrimitive(newValue) && newValue === value) {
        changed = true;
      }
    }
    if (changed) {
      version++;
      notify === null || notify === void 0 ? void 0 : notify();
    }
  };
  return {
    subscribe: (onStoreChange) => {
      notify = onStoreChange;
      if (!dispose && resubscribe) {
        resubscribe();
      }
      return () => {
        dispose === null || dispose === void 0 ? void 0 : dispose();
        dispose = void 0;
      };
    },
    getVersion: () => version,
    run: (selector) => {
      _selector = selector;
      dispose === null || dispose === void 0 ? void 0 : dispose();
      const { value, dispose: _dispose, resubscribe: _resubscribe } = trackSelector(
        selector,
        _update,
        void 0,
        void 0,
        /*createResubscribe*/
        true,
        /*inRender*/
        true
      );
      dispose = _dispose;
      resubscribe = _resubscribe;
      prev = value;
      return value;
    }
  };
}
function useSelector(selector, options) {
  if (tracking.inRender) {
    return computeSelector(selector);
  }
  const ref = (0, import_react.useRef)();
  if (!ref.current) {
    ref.current = createSelectorFunctions(options);
  }
  const { subscribe, getVersion, run } = ref.current;
  const value = run(selector);
  shim.exports.useSyncExternalStore(subscribe, getVersion, getVersion);
  if (options === null || options === void 0 ? void 0 : options.suspend) {
    if (isPromise(value)) {
      throw value;
    } else if (value === null || value === void 0 ? void 0 : value.error) {
      throw value.error;
    }
  }
  return value;
}
function Computed({ children }) {
  return useSelector(children, { skipCheck: true });
}
var hasSymbol = typeof Symbol === "function" && Symbol.for;
function createReactiveComponent(component, observe2, reactive2, bindKeys) {
  const ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : (
    // eslint-disable-next-line react/display-name, @typescript-eslint/no-unused-vars
    typeof import_react.forwardRef === "function" && (0, import_react.forwardRef)((props) => null)["$$typeof"]
  );
  const ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : (
    // eslint-disable-next-line react/display-name, @typescript-eslint/no-unused-vars
    typeof import_react.forwardRef === "function" && (0, import_react.memo)((props) => null)["$$typeof"]
  );
  if (component["__legend_proxied"])
    return component;
  let useForwardRef = false;
  let useMemo2 = false;
  let render = component;
  if (ReactMemoSymbol && render["$$typeof"] === ReactMemoSymbol && render["type"]) {
    useMemo2 = true;
    render = render["type"];
  }
  if (ReactForwardRefSymbol && render["$$typeof"] === ReactForwardRefSymbol) {
    useForwardRef = true;
    render = render["render"];
    if (typeof render !== "function") {
      throw new Error(`[legend-state] \`render\` property of ForwardRef was not a function`);
    }
  }
  const proxyHandler = {
    apply(target, thisArg, argArray) {
      if (reactive2) {
        const props = argArray[0];
        const propsOut = {};
        const keys = Object.keys(props);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const p = props[key];
          if (key === "children" && (isFunction(p) || isObservable(p))) {
            props[key] = useSelector(p, { skipCheck: true });
          } else if (key.startsWith("$") || key.endsWith("$")) {
            const k = key.endsWith("$") ? key.slice(0, -1) : key.slice(1);
            propsOut[k] = useSelector(p);
            const bind = bindKeys === null || bindKeys === void 0 ? void 0 : bindKeys[k];
            if (bind && isObservable(p)) {
              if (bind.defaultValue !== void 0 && propsOut[k] === void 0) {
                propsOut[k] = bind.defaultValue;
              }
              const handlerFn = (e) => {
                var _a;
                p.set(bind.getValue(e));
                (_a = props[bind.handler]) === null || _a === void 0 ? void 0 : _a.call(props, e);
              };
              propsOut[bind.handler] = // If in development mode, don't memoize the handler. fix fast refresh bug
              true ? handlerFn : (0, import_react.useCallback)(handlerFn, [props[bind.handler], bindKeys]);
            }
            delete propsOut[key];
          } else if (propsOut[key] === void 0) {
            propsOut[key] = p;
          }
        }
        argArray[0] = propsOut;
      }
      if (observe2) {
        return useSelector(() => Reflect.apply(target, thisArg, argArray), { skipCheck: true });
      } else {
        return Reflect.apply(target, thisArg, argArray);
      }
    }
  };
  const proxy = new Proxy(render, proxyHandler);
  let ret;
  if (useForwardRef) {
    ret = (0, import_react.forwardRef)(proxy);
    ret["__legend_proxied"] = true;
  } else {
    ret = proxy;
  }
  return observe2 || useMemo2 ? (0, import_react.memo)(ret) : ret;
}
function reactive(component, bindKeys) {
  return createReactiveComponent(component, false, true, bindKeys);
}
var Memo = (0, import_react.memo)(Computed, () => true);
var ReactiveFns = /* @__PURE__ */ new Map();
var ReactiveFnBinders = /* @__PURE__ */ new Map();
var Reactive = new Proxy({}, {
  get(target, p) {
    if (!target[p]) {
      const Component = ReactiveFns.get(p) || p;
      const render = (0, import_react.forwardRef)((props, ref) => {
        const propsOut = { ...props };
        if (ref && (isFunction(ref) || !isEmpty(ref))) {
          propsOut.ref = ref;
        }
        return (0, import_react.createElement)(Component, propsOut);
      });
      target[p] = reactive(render, ReactiveFnBinders.get(p));
    }
    return target[p];
  }
});

// node_modules/@legendapp/state/config/enableReactUse.mjs
function enableReactUse() {
  configureLegendState({
    observableFunctions: {
      use: (node, options) => useSelector(internal.getProxy(node), options)
    }
  });
}
export {
  enableReactUse
};
/*! Bundled license information:

@legendapp/state/react.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@legendapp/state/react.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@legendapp_state_config_enableReactUse.js.map
