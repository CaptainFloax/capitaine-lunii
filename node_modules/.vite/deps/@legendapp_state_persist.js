import {
  batch,
  constructObjectWithPath,
  deconstructObjectWithPath,
  internal,
  isArray,
  isEmpty,
  isObject,
  isPromise,
  isString,
  mergeIntoObservable,
  observable,
  setAtPath,
  setInObservableAtPath,
  symbolDelete,
  when
} from "./chunk-OUCLKSCB.js";
import "./chunk-AUZ3RYOM.js";

// node_modules/@legendapp/state/persist.mjs
var observablePersistConfiguration = {};
function configureObservablePersistence(options) {
  Object.assign(observablePersistConfiguration, options);
}
var validateMap;
function transformPath(path, pathTypes, map) {
  const data = {};
  let d = data;
  for (let i = 0; i < path.length; i++) {
    d = d[path[i]] = i === path.length - 1 ? null : pathTypes[i] === "array" ? [] : {};
  }
  let value = transformObject(data, map);
  const pathOut = [];
  for (let i = 0; i < path.length; i++) {
    const key = Object.keys(value)[0];
    pathOut.push(key);
    value = value[key];
  }
  return pathOut;
}
function transformObject(dataIn, map) {
  if (true) {
    validateMap(map);
  }
  let ret = dataIn;
  if (dataIn) {
    if (dataIn === symbolDelete)
      return dataIn;
    if (isString(dataIn)) {
      return map[dataIn];
    }
    ret = {};
    const dict = Object.keys(map).length === 1 && map["_dict"];
    for (const key in dataIn) {
      let v = dataIn[key];
      if (dict) {
        ret[key] = transformObject(v, dict);
      } else {
        const mapped = map[key];
        if (mapped === void 0) {
          if (key !== "@") {
            ret[key] = v;
            if (true) {
              console.error("A fatal field transformation error has occurred", key, dataIn, map);
            }
          }
        } else if (mapped !== null) {
          if (v !== void 0 && v !== null) {
            if (map[key + "_val"]) {
              const mapChild = map[key + "_val"];
              if (isArray(v)) {
                v = v.map((vChild) => mapChild[vChild]);
              } else {
                v = mapChild[v];
              }
            } else if (map[key + "_arr"] && isArray(v)) {
              const mapChild = map[key + "_arr"];
              v = v.map((vChild) => transformObject(vChild, mapChild));
            } else if (isObject(v)) {
              if (map[key + "_obj"]) {
                v = transformObject(v, map[key + "_obj"]);
              } else if (map[key + "_dict"]) {
                const mapChild = map[key + "_dict"];
                const out = {};
                for (const keyChild in v) {
                  out[keyChild] = transformObject(v[keyChild], mapChild);
                }
                v = out;
              }
            }
          }
          ret[mapped] = v;
        }
      }
    }
  }
  return ret;
}
function transformObjectWithPath(obj, path, pathTypes, fieldTransforms) {
  const constructed = constructObjectWithPath(path, obj, pathTypes);
  const transformed = transformObject(constructed, fieldTransforms);
  const transformedPath = transformPath(path, pathTypes, fieldTransforms);
  return { path: transformedPath, obj: deconstructObjectWithPath(transformedPath, transformed) };
}
var invertedMaps = /* @__PURE__ */ new WeakMap();
function invertFieldMap(obj) {
  const existing = invertedMaps.get(obj);
  if (existing)
    return existing;
  const target = {};
  for (const key in obj) {
    const val = obj[key];
    if (key === "_dict") {
      target[key] = invertFieldMap(val);
    } else if (key.endsWith("_obj") || key.endsWith("_dict") || key.endsWith("_arr") || key.endsWith("_val")) {
      const keyMapped = obj[key.replace(/_obj|_dict|_arr|_val$/, "")];
      const suffix = key.match(/_obj|_dict|_arr|_val$/)[0];
      target[keyMapped + suffix] = invertFieldMap(val);
    } else if (typeof val === "string") {
      target[val] = key;
    }
  }
  invertedMaps.set(obj, target);
  return target;
}
if (true) {
  validateMap = function(record) {
    const values = Object.values(record).filter((value) => {
      if (isObject(value)) {
        validateMap(value);
      } else {
        return isString(value);
      }
    });
    const uniques = Array.from(new Set(values));
    if (values.length !== uniques.length) {
      console.error("Field transform map has duplicate values", record, values.length, uniques.length);
    }
    return record;
  };
}
var mapPersistences = /* @__PURE__ */ new WeakMap();
var persistState = observable({ inRemoteSync: false });
var metadatas = /* @__PURE__ */ new WeakMap();
var promisesLocalSaves = /* @__PURE__ */ new Set();
function parseLocalConfig(config) {
  return isString(config) ? { table: config, config: { name: config } } : { table: config.name, config };
}
function doInOrder(arg1, arg2) {
  return isPromise(arg1) ? arg1.then(arg2) : arg2(arg1);
}
function adjustSaveData(value, path, pathTypes, { adjustData, fieldTransforms }) {
  if (fieldTransforms || (adjustData === null || adjustData === void 0 ? void 0 : adjustData.save)) {
    const transform = () => {
      if (fieldTransforms) {
        const { obj, path: pathTransformed } = transformObjectWithPath(value, path, pathTypes, fieldTransforms);
        value = obj;
        path = pathTransformed;
      }
      return { value, path };
    };
    if (adjustData === null || adjustData === void 0 ? void 0 : adjustData.save) {
      const constructed = constructObjectWithPath(path, value, pathTypes);
      const saved = adjustData.save(constructed);
      const deconstruct = (toDeconstruct) => {
        value = deconstructObjectWithPath(path, toDeconstruct);
        return transform();
      };
      return doInOrder(saved, deconstruct);
    }
    return transform();
  }
  return { value, path };
}
function adjustLoadData(value, { adjustData, fieldTransforms }, doUserAdjustData) {
  if (fieldTransforms) {
    const inverted = invertFieldMap(fieldTransforms);
    value = transformObject(value, inverted);
  }
  if (doUserAdjustData && (adjustData === null || adjustData === void 0 ? void 0 : adjustData.load)) {
    value = adjustData.load(value);
  }
  return value;
}
async function updateMetadataImmediate(obs, localState, obsState, persistOptions, newMetadata) {
  const saves = Array.from(promisesLocalSaves);
  if (saves.length > 0) {
    await Promise.all(saves);
  }
  const { persistenceLocal } = localState;
  const local = persistOptions.local;
  const { table, config } = parseLocalConfig(local);
  const oldMetadata = metadatas.get(obs);
  const { modified, pending } = newMetadata;
  const needsUpdate = pending || modified && (!oldMetadata || modified !== oldMetadata.modified);
  if (needsUpdate) {
    const metadata = Object.assign({}, oldMetadata, newMetadata);
    metadatas.set(obs, metadata);
    await persistenceLocal.updateMetadata(table, metadata, config);
    if (modified) {
      obsState.dateModified.set(modified);
    }
  }
}
function updateMetadata(obs, localState, obsState, persistOptions, newMetadata) {
  if (localState.timeoutSaveMetadata) {
    clearTimeout(localState.timeoutSaveMetadata);
  }
  localState.timeoutSaveMetadata = setTimeout(() => updateMetadataImmediate(obs, localState, obsState, persistOptions, newMetadata), 30);
}
var _queuedChanges = [];
async function processQueuedChanges() {
  const queuedChanges = _queuedChanges;
  _queuedChanges = [];
  const changes = await Promise.all(queuedChanges.map(prepChange));
  changes.forEach(doChange);
}
async function prepChange(queuedChange) {
  const { obsState, changes, localState, persistOptions, inRemoteChange, isApplyingPending } = queuedChange;
  const local = persistOptions.local;
  const { config: configLocal } = parseLocalConfig(local);
  const configRemote = persistOptions.remote;
  const saveLocal = local && !configLocal.readonly && !isApplyingPending && obsState.isEnabledLocal.peek();
  const saveRemote = !inRemoteChange && configRemote && !configRemote.readonly && obsState.isEnabledRemote.peek();
  if (saveLocal || saveRemote) {
    if (saveLocal && !obsState.isLoadedLocal.peek()) {
      console.error("[legend-state] WARNING: An observable was changed before being loaded from persistence", local);
      return;
    }
    const changesLocal = [];
    const changesRemote = [];
    const changesPaths = /* @__PURE__ */ new Set();
    let promisesAdjustData = [];
    for (let i = changes.length - 1; i >= 0; i--) {
      const { path } = changes[i];
      let found = false;
      if (changesPaths.size > 0) {
        for (let u = 0; u < path.length; u++) {
          if (changesPaths.has((u === path.length - 1 ? path : path.slice(0, u + 1)).join("/"))) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        const pathStr = path.join("/");
        changesPaths.add(pathStr);
        const { prevAtPath, valueAtPath, pathTypes } = changes[i];
        if (saveLocal) {
          const promiseAdjustLocal = adjustSaveData(valueAtPath, path, pathTypes, configLocal);
          promisesAdjustData.push(doInOrder(promiseAdjustLocal, ({ path: pathAdjusted, value: valueAdjusted }) => {
            if (!pathAdjusted.includes(void 0)) {
              changesLocal.push({
                path: pathAdjusted,
                pathTypes,
                prevAtPath,
                valueAtPath: valueAdjusted,
                pathStr
              });
            }
          }));
        }
        if (saveRemote) {
          const promiseAdjustRemote = adjustSaveData(valueAtPath, path, pathTypes, configRemote);
          promisesAdjustData.push(doInOrder(promiseAdjustRemote, ({ path: pathAdjusted, value: valueAdjusted }) => {
            if (!pathAdjusted.includes(void 0)) {
              if (!localState.pendingChanges) {
                localState.pendingChanges = {};
              }
              if (!localState.pendingChanges[pathStr]) {
                localState.pendingChanges[pathStr] = { p: prevAtPath !== null && prevAtPath !== void 0 ? prevAtPath : null, t: pathTypes };
              }
              localState.pendingChanges[pathStr].v = valueAtPath;
              changesRemote.push({
                path: pathAdjusted,
                pathTypes,
                prevAtPath,
                valueAtPath: valueAdjusted,
                pathStr
              });
            }
          }));
        }
      }
    }
    promisesAdjustData = promisesAdjustData.filter(Boolean);
    if (promisesAdjustData.length > 0) {
      await Promise.all(promisesAdjustData);
    }
    return { queuedChange, changesLocal, changesRemote };
  }
}
async function doChange(changeInfo) {
  var _a, _b;
  if (!changeInfo)
    return;
  const { queuedChange, changesLocal, changesRemote } = changeInfo;
  const { obs, obsState, localState, persistOptions } = queuedChange;
  const { persistenceLocal, persistenceRemote } = localState;
  const local = persistOptions.local;
  const { table, config: configLocal } = parseLocalConfig(local);
  const configRemote = persistOptions.remote;
  if (changesRemote.length > 0) {
    await updateMetadataImmediate(obs, localState, obsState, persistOptions, {
      pending: localState.pendingChanges
    });
  }
  if (changesLocal.length > 0) {
    let promiseSet = persistenceLocal.set(table, changesLocal, configLocal);
    if (promiseSet) {
      promiseSet = promiseSet.then(() => {
        promisesLocalSaves.delete(promiseSet);
      });
      promisesLocalSaves.add(promiseSet);
      await promiseSet;
    }
  }
  if (changesRemote.length > 0) {
    await when(() => obsState.isLoadedRemote.get() || configRemote.allowSaveIfError && obsState.remoteError.get());
    const saves = await Promise.all(changesRemote.map(async (change) => {
      const { path, valueAtPath, prevAtPath, pathTypes, pathStr } = change;
      return persistenceRemote.save({
        obs,
        state: obsState,
        options: persistOptions,
        path,
        pathTypes,
        valueAtPath,
        prevAtPath
      }).then(({ changes, dateModified }) => ({ changes, dateModified, pathStr }));
    }));
    if (saves.filter(Boolean).length > 0) {
      if (local) {
        const metadata = {};
        const pending = (_a = persistenceLocal.getMetadata(table, configLocal)) === null || _a === void 0 ? void 0 : _a.pending;
        let adjustedChanges = [];
        for (let i = 0; i < saves.length; i++) {
          const save = saves[i];
          if (save) {
            const { changes, dateModified, pathStr } = save;
            if (pending === null || pending === void 0 ? void 0 : pending[pathStr]) {
              delete pending[pathStr];
              delete localState.pendingChanges[pathStr];
              metadata.pending = pending;
            }
            if (dateModified) {
              metadata.modified = dateModified;
            }
            if (changes && !isEmpty(changes)) {
              adjustedChanges.push(adjustLoadData(changes, persistOptions.remote, false));
            }
          }
        }
        if (adjustedChanges.length > 0) {
          if (adjustedChanges.some((change) => isPromise(change))) {
            adjustedChanges = await Promise.all(adjustedChanges);
          }
          onChangeRemote(() => mergeIntoObservable(obs, ...adjustedChanges));
        }
        if (local && !isEmpty(metadata)) {
          updateMetadata(obs, localState, obsState, persistOptions, metadata);
        }
      }
      (_b = localState.onSaveRemote) === null || _b === void 0 ? void 0 : _b.call(localState);
    }
  }
}
function onObsChange(obs, obsState, localState, persistOptions, { changes }) {
  if (!internal.globalState.isLoadingLocal) {
    const inRemoteChange = internal.globalState.isLoadingRemote;
    const isApplyingPending = localState.isApplyingPending;
    _queuedChanges.push({
      obs,
      obsState,
      localState,
      persistOptions,
      changes,
      inRemoteChange,
      isApplyingPending
    });
    if (_queuedChanges.length === 1) {
      queueMicrotask(processQueuedChanges);
    }
  }
}
function onChangeRemote(cb) {
  when(() => !persistState.inRemoteSync.get(), () => {
    persistState.inRemoteSync.set(true);
    internal.globalState.isLoadingRemote = true;
    batch(cb, () => {
      internal.globalState.isLoadingRemote = false;
      persistState.inRemoteSync.set(false);
    });
  });
}
async function loadLocal(obs, persistOptions, obsState, localState) {
  var _a, _b;
  const { local } = persistOptions;
  const localPersistence = persistOptions.persistLocal || observablePersistConfiguration.persistLocal;
  if (local) {
    const { table, config } = parseLocalConfig(local);
    if (!localPersistence) {
      throw new Error("Local persistence is not configured");
    }
    if (!mapPersistences.has(localPersistence)) {
      const persistenceLocal2 = new localPersistence();
      const mapValue = { persist: persistenceLocal2, initialized: observable(false) };
      mapPersistences.set(localPersistence, mapValue);
      if (persistenceLocal2.initialize) {
        const initializePromise = (_a = persistenceLocal2.initialize) === null || _a === void 0 ? void 0 : _a.call(persistenceLocal2, observablePersistConfiguration.persistLocalOptions);
        if (isPromise(initializePromise)) {
          await initializePromise;
        }
      }
      mapValue.initialized.set(true);
    }
    const { persist: persistenceLocal, initialized } = mapPersistences.get(localPersistence);
    localState.persistenceLocal = persistenceLocal;
    if (!initialized.get()) {
      await when(initialized);
    }
    if (persistenceLocal.loadTable) {
      const promise = persistenceLocal.loadTable(table, config);
      if (promise) {
        await promise;
      }
    }
    let value = persistenceLocal.getTable(table, config);
    const metadata = persistenceLocal.getMetadata(table, config);
    if (metadata) {
      metadatas.set(obs, metadata);
      localState.pendingChanges = metadata.pending;
      obsState.dateModified.set(metadata.modified);
    }
    if (value !== null && value !== void 0) {
      let { adjustData, fieldTransforms } = config;
      if (fieldTransforms) {
        const valueLoaded = (_b = persistenceLocal.getTableTransformed) === null || _b === void 0 ? void 0 : _b.call(persistenceLocal, table, config);
        if (valueLoaded) {
          value = valueLoaded;
          fieldTransforms = void 0;
        }
      }
      value = adjustLoadData(value, { adjustData, fieldTransforms }, true);
      if (isPromise(value)) {
        value = await value;
      }
      batch(() => {
        internal.globalState.isLoadingLocal = true;
        mergeIntoObservable(obs, value);
      }, () => {
        internal.globalState.isLoadingLocal = false;
      });
    }
    obsState.peek().clearLocal = () => Promise.all([
      persistenceLocal.deleteTable(table, config),
      persistenceLocal.deleteMetadata(table, config)
    ]);
  }
  obsState.isLoadedLocal.set(true);
}
function persistObservable(obs, persistOptions) {
  const { remote, local } = persistOptions;
  const remotePersistence = persistOptions.persistRemote || (observablePersistConfiguration === null || observablePersistConfiguration === void 0 ? void 0 : observablePersistConfiguration.persistRemote);
  const localState = {};
  const obsState = observable({
    isLoadedLocal: false,
    isLoadedRemote: false,
    isEnabledLocal: true,
    isEnabledRemote: true,
    clearLocal: void 0,
    sync: () => Promise.resolve(),
    getPendingChanges: () => localState.pendingChanges
  });
  if (local) {
    loadLocal(obs, persistOptions, obsState, localState);
  }
  if (remote) {
    if (!remotePersistence) {
      throw new Error("Remote persistence is not configured");
    }
    if (!mapPersistences.has(remotePersistence)) {
      mapPersistences.set(remotePersistence, { persist: new remotePersistence() });
    }
    localState.persistenceRemote = mapPersistences.get(remotePersistence).persist;
    let isSynced = false;
    const sync = async () => {
      var _a, _b;
      if (!isSynced) {
        isSynced = true;
        localState.onSaveRemote = (_a = persistOptions.remote) === null || _a === void 0 ? void 0 : _a.onSaveRemote;
        const dateModified = (_b = metadatas.get(obs)) === null || _b === void 0 ? void 0 : _b.modified;
        localState.persistenceRemote.listen({
          state: obsState,
          obs,
          options: persistOptions,
          dateModified,
          onLoad: () => {
            obsState.isLoadedRemote.set(true);
          },
          onChange: async ({ value, path, pathTypes, mode, dateModified: dateModified2 }) => {
            if (value !== void 0) {
              value = adjustLoadData(value, remote, true);
              if (isPromise(value)) {
                value = await value;
              }
              const invertedMap = remote.fieldTransforms && invertFieldMap(remote.fieldTransforms);
              if (path.length && invertedMap) {
                path = transformPath(path, pathTypes, invertedMap);
              }
              if (mode === "dateModified") {
                if (dateModified2 && !isEmpty(value)) {
                  onChangeRemote(() => {
                    setInObservableAtPath(obs, path, value, "assign");
                  });
                }
              } else {
                const pending2 = localState.pendingChanges;
                if (pending2) {
                  Object.keys(pending2).forEach((key) => {
                    const p = key.split("/").filter((p2) => p2 !== "");
                    const { v, t } = pending2[key];
                    value = setAtPath(value, p, t, v, obs.peek(), (path2, value2) => {
                      delete pending2[key];
                      pending2[path2.join("/")] = {
                        p: null,
                        v: value2,
                        t: t.slice(0, path2.length)
                      };
                    });
                  });
                }
                onChangeRemote(() => {
                  setInObservableAtPath(obs, path, value, mode);
                });
              }
            }
            if (dateModified2 && local) {
              updateMetadata(obs, localState, obsState, persistOptions, {
                modified: dateModified2
              });
            }
          }
        });
        await when(() => obsState.isLoadedRemote.get() || remote.allowSaveIfError && obsState.remoteError.get());
        const pending = localState.pendingChanges;
        if (pending && !isEmpty(pending)) {
          localState.isApplyingPending = true;
          const keys = Object.keys(pending);
          const changes = [];
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const path = key.split("/").filter((p2) => p2 !== "");
            const { p, v, t } = pending[key];
            changes.push({ path, valueAtPath: v, prevAtPath: p, pathTypes: t });
          }
          onObsChange(obs, obsState, localState, persistOptions, {
            value: obs.peek(),
            // TODO getPrevious if any remote persistence layers need it
            getPrevious: () => void 0,
            changes
          });
          localState.isApplyingPending = false;
        }
      }
    };
    if (remote.manual) {
      obsState.assign({ sync });
    } else {
      when(() => !local || obsState.isLoadedLocal.get(), sync);
    }
  }
  when(obsState.isLoadedLocal, function() {
    obs.onChange(onObsChange.bind(this, obs, obsState, localState, persistOptions));
  });
  return obsState;
}
function isInRemoteChange() {
  return internal.globalState.isLoadingRemote;
}
var internal2 = {
  observablePersistConfiguration
};
export {
  configureObservablePersistence,
  internal2 as internal,
  invertFieldMap,
  isInRemoteChange,
  mapPersistences,
  onChangeRemote,
  persistObservable,
  persistState,
  transformObject,
  transformPath
};
//# sourceMappingURL=@legendapp_state_persist.js.map
